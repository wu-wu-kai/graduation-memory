# 毕业纪念
## 主要内容
主要包含我的毕业设计的一部分数值模拟的内容，其中前一部分主要是未来寻找计数率T，浓度C，扩散系数D之间的关系；后一部分是使用不同粒径分布的大量粒子数值模拟来验证文章中浓度计算方法的正确性。第一部分，我们通过合理的简化把运动直接放在了一维空间内，同时我们假设粒子只要通过检测平面就总是能够被探测到。Brown()这个函数是最重要的部分，它用来模拟一个扩散系数D确定的粒子的布朗运动。你可以对它做许多改动，特别是修改函数的输入值（在这里函数的输入值并不重要，它只是用来确定模拟时的几个物理参数），比如将它的输入值改为扩散系数D或者粒子数N，或者干脆不设输入值，而是通过函数开头处的几个变量定义来控制D或N。另外，为了实现浓度的自由调整，你可以随意改变模拟空间的大小（因为空间内的粒子个数至少是1）。关于粒子是否穿过检测平面的比较，是用当前时刻和上一时刻的粒子Z坐标来判断的，为了运行的快，所以检测平面默认为z=0，这样就可以直接用逻辑运算符作用于符号来判断。所以不要修改这一部分，你可以通过调整模拟空间的边界来改变检测平面的相对位置。第二部分主要是用来模拟多分散情况的，也就是各个粒子的大小不相同这一比较现实的情况。你需要先给定一个分布（默认就是正态分布），然后程序会按照给定的分布来生成一组随机数（默认为1000个，这时你必须调整模拟空间的大小来调节浓度），这些随机数就是粒子的扩散系数D（在同一液体中不同粒子的D只受粒径的影响）。接着就是让这些粒子进行布朗运动，并统计计数率T，这和前面差不多，只是粒子数量很大罢了，最终会拿总计数率T来和先前生成的粒子分布来计算粒子的浓度。你可以用这个计算值来和设定的浓度来作比较。
## 注意事项
1. 第一部分代码中有一些被注释的部分，你可以随意恢复那些代码并调试那些功能，它们没有风险。
2. 所有的代码绘图部分和计算部分都是分开的，这样有利于调试。所以运行绘图程序之前请检查是否已经生成对应的数据文件。（通常情况你只要把它们放在同一地址并运行一次，数据文件就会自动生成）
3. Brown()函数运行速度可能不能满足你的要求，这时你可以将数据类型改变，比如改为单精度浮点数，这样可以有效节约时间。
4. 每次Brown()函数结束之前，粒子的轨迹会被存储，你可以将每次模拟的粒子运动图画出来。所以不要一次性将模拟的粒子数调的特别大，防止爆内存。
5. 第二部分的代码使用了并行计算，因此性能和你的设备的多核能力关系很大。如果使用服务器，可以将粒子数量再提升两个数量级。
6. 运行第二部分代码前请调试一下，特别是Intel的设备可以尝试调整一下multiprocessing函数中的线程数，或许能使性能大幅提高。
7. 运行第二部分代码前应该关闭正在运行的多余的进程，运行时可能会出现其它进程卡死的现象，这时正常的，不必担心。
8. 第二部分代码提供了七份原始数据，如果你不想运行模拟部分，可以直接运行后续的计算和画图部分，只要注意文件地址不要选错即可。
